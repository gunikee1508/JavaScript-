function teste2(nota)
{
    if(nota > 7) // sim, isto é uma sentença de codigo
        ;

    {
        console.log(nota);
    }
}

// o ; ali é uma instrução vazia. então, console.log(nota) sempre será impresso, não tem condiçao pra isso.

const imprimirResultado = function teste2(nota)
{
    if(nota >= 7)
    {
        console.log('Aprovado');
    }
    else
    {
        console.log('Reprovado');
    }
}

imprimirResultado('Epa'); // vai ser false, vai imprimir 'reprovado', por falha do javascript, q é uma linguagem fracamente tipada

Number.prototype.entre = function (inicio, fim)
{
    return this >= inicio&& this <= fim
}

const imprimirResultado = function (nota)
{
    if(nota.entre(9,10))
    {
        console.log('Quadro de Honra');
    }
    else if (nota.entre(7, 8.99))
    {
        console.log('Aprovado');
    }
    else if (nota.entre(4, 6.99))
    {
        console.log('Recuperação');
    }
    else if (nota.entre(70, 3.99))
    {
        console.log('Reprovado');
    }
}

imprimirResultado(8.5);
imprimirResultado(5);

---
com switch: melhor pra necessidades multiplas

const imprimirResultado = function (nota)
{
    switch(Math.floor(nota)){
        case 10:
        case 9:
            console.log('Quadro de Honra');
        case 8: case 7:
            console.log('Aprovado');
        case 6: case 5: case 4:
            console.log('Recuperação');
        case 3: case 2: case 1:
            console.log('Reprovado');
        default:
            console.log("Nota inválida");
    }
}

imprimirResultado(4);


////////// 

- WHILE:

function getInteiroAleatorioEntre(min, max)
{
    const valor = Math.random() * (max-min) + min
    return Math.floor(valor);
}

let opcao = -1;

// enquanto a expressão for verdadeira, continue executando o laço até q seja falso
while (opcao != -1)
{
    opcao = getInteiroAleatorioEntre(-1, 10); // o valor tá sendo alterado pela função
    console.log('A opção escolhida foi `${opcao}`');
}

// ele tá sempre sorteando, até q saia um -1.

//////////////////////////////

const notas = [6.5, 7.5, 9.0, 3.2, 4.1];

for(let i = 0; i < notas.length; i++)
{
    console.log(`A nota agora é: ${notas[i]}`);
}

///////////////////

FOR IN:
const notas = [6.7, 7.4, 8.3, 7.7];

// o FOR IN vai te dar os indices do elemento, como se fosse te dar os atributos de um array (ex.: o 1 elemento do array é 0, o 2 elemento do arary é 1). foreach é melhor.

for (let i in notas) // para cada um dos elementos de notas vai te devolver um indice 'i'. bom usar 'let' para garantir que 'i' estará apenas naquele laço, isto é, variavel local daquele laço, presente apenas neste escopo.
{
    console.log(i, notas[i]); // vai mostrar os indices e o que há dentro de cada índice
} 



-- Outro exemplo:

const pessoa = {
    nome: 'Gustavo',
    sobrenome: 'Marcon',
    idade: 20,
    peso: 60
}

for(let atributo in pessoa)
{
    console.log(`${atributo} : ${pessoaNova[atributo]}`);
}

///////////////

Usando break e continue:

const nums = [1,2,3,4,5,6,7,8,9,10];

for (x in nums){
    if (x==5) break;
    console.log(`x = ${nums[x]}`);
}

for (y in nums)
{
    if (y==5) continue; // 'continue' simplesmente interrompe a repetição corrente e vai para a proxima repetição
    console.log(`${y} = ${nums[y]}`);
}

// Agora com pares:
externo: for (a in nums) // atr
{
    for(b in nums)
    {
        if(a == 2 && b == 3) break externo
        console.log(`Par = ${a}, ${b}`);
    }
}

/\ criei um rotulo chamado 'externo', e esse rotulo fica associado a um laço 'for'. dentro deste for, criei um outro for q teoricamente seria um for interno, onde 'a' sempre o indice de nums, e b sendo indice de nums também. se eu não tivesse colocado 'break externo', e sim apenas 'break', ele iria chamar apenas o break do for "interno" (q é o b in nums), pq é o laço mais proximo do break. se eu quiser criar um break mais externo, so a partir de um rotulo, por isso tenho o 'externo'.

/\ Isso já nem é mais muito utilizado, melhor quebrar em métodos, foreach, etc.


--------------

Função:
// Criar de forma literal
function func1() { } // toda função retorna ao menos algum valor. se não definir o retorno, ele retorna ao menos undefined. o bloco em função é obrigatorio

// Armazenar em uma variável:
const fun2 = function () { }

// Armazenar em um array:
const array = [function (a,b) { return a + b }, fun1, fun2]; // posso armazenar criando uma funçao anonima direto, ou criar uma funçao armazenando em uma variavel e colocar esta variavel no array

console.log(array[0](2,3)); // chamei ali o array de indice 0, q é uma funçao e, a essa funçao, passei os parametros '2' e '3'

// Armazenando em um atributo de objeto:
const obj = {}; // aqui criei um objeto, lembre-se, {} define objeto

obj.falar = function () { return 'Opa' };

console.log(obj.falar()); // tem q colocar os parenteses () para de fato invocar a função

// Passar função como parametro para outra função:
function run (fun) // criei uma função chamada run, recebe como parametro 'fun' ( espero receber como parametro uma função)
{
    fun(); // executando uma função, graças ao o que ta entre parenteses.
}

run(function () { console.log('Executando....') }); // chamei e passei como parametro uma função. aqui, não to executando uma função, apenas em fun(), dentro da função fun.

// Além de conseguir passar como parametro, tbm é possivel retornar uma função como parametro.

// Uma função pode retornar/conter uma/outra função
function soma(a,b) {
    return function(c) {
        console.log(a+b+c);
    }
}

soma(2,3)(4); // é uma forma de fazer chamando a função soma e depois já chamar diretamente a outra função. passei primeiro o parametro de 'soma' e depois o parametro da funçao q ta retornando a tal função. o resultado aí será 9.

const cincoMais = soma(2,3); // mas tb posso armazenar o resultado dessa variável em uma constante/variável e depois usar essa constante/variável pra continuar a chamada da função
cincoMais(4);

////////////

- Parâmetros e retorno são opcionais
function area(largura, altura)
{
    const area = largura * altura;
    if(area > 20)
    {
        console.log(`Valor acima do permitido: ${area}m2`);
    }
    else
    {
        return area
    }
}

console.log(area(2,2)); // vai executar normalmente
console.log(area(2)); // vai dar NaN, pq simplesmente não tem o 2 parametro.
console.log(area()); // só dá NaN
console.log(area(2,3,17,22,44)); // vai ler apenas os 2 primeiros e vai ignorar o resto 
 
////////////////

Parametros variáveis -
function soma() // o fato de não receber nenhum parametro não significa que não se pode passar nenhum parametro, mas pode passar parametro sim, e dentro da função recuperar esses parametros a partir de uma propriedade chamada arguments
{
    let soma = 0;
    for (i in arguments) // arguments é um array, e com 'i' vou pegar o indice de cada elemento do array. posso pegar cada um dos elementos e ir somando a variavel soma. arguments é o array interno de uma função que tem todos os argumentos q foram passados.
    { 
        soma += arguments[i];
    }
    return soma; // aq é o resultado de todas as somas q passei
}
console.log(soma()); // resulta '0', é a soma total
console.log(soma(1)); // resulta em 1
console.log(soma(1.1, 2.2, 3.3)); // resulta em 6.6, soma de tudo
// ele não se limita apenas a numero, claro, se vc der:
console.log(soma(1.1, 2.2, "testeeweee")); // vai resultar na soma de 1.1 com 2.2 e juntar com 'testeeweeee'

// ---> tem outros operadores, como o rest, veremos pra frente

-----------------

parametro padrão-
function soma1(a,b,c) // vc vai receber valor a, b e c de uma soma
{
    a = a || 1; // a vai receber 'a' se for true, se for false ele recebe '1'
    b = b || 1; // a vai receber 'a' se for true, se for false ele recebe '1'
    c = c || 1;
    return a + b + c; // com ctz ele não vai ser um valor nulo ou undefined, pq se for false, recebe '1' como valor
}
console.log(soma1(), soma1(1,2,3), soma1(0,0,0)); // primeiro vai retornar '3' (pq é a soma de 1+1+1). depois, vai retornar 5. dps, mesmo passando '0,0,0', ele vai retornar '3', pq '0' é sempre false, então ele gera '1' [daí a soma de cada um pra dar 3].


// outras estratégias pra gerar um valor padrão
function soma2(a,b,c)
{
    a = a !== undefined ? a : 1; // 1º estratégia: a vai receber o seguinte: se a for diferente de undefined (se tiver algum valor), ela recebe o valor de 'a', q foi dado no parametro, senão, recebe como padrão o valor '1'.
    b = 1 in arguments? b : 1; // 2º estrategia - dentro de 'arguments' existe o valor 1? se existir, b pega o valor de b, senão, pega o valor '1' como padrão. aqui é '1 in arguments' pq 'b' é de indice '1', se fosse 'a' seria '0 in arguments? [...]'
    c = isNaN(c) ? 1 : c; // essa é a estrategia mais segura para valores numericos.
    return a + b + c;
}
console.log(soma2(1,2,3)); // soma todos normalmente
console.log(soma2()); // vai mostrar '3', pq recebeu valor padra
console.log(soma2(1)); // vai mostrar '3', mas recebeu o primeiro parametro (a) mas caiu em true, b e c receberam 1 como valor padrão pq cairam em false
console.log(soma2(5,6)); // vai mostrar '12', pq a e b tão em true, fizeram soma, mas c tá em false e caiu como valor padrão '1'.
console.log(soma2(5,6,"Olá")); // mesma coisa do de cima.

// MAS, tem a melhor forma como valor numerico:
function soma3(a = 1, b = 1, c = 1)
{
    return a + b + c;
}
console.log(soma3(), soma3(3), soma3(1,2,3), soma3(0,0,0)); // vai sempre receber '1' como padrão caso não definido

// o valor padrao acima de funçao é pra colocar em parametros de funçao, mas se tiver criado variavel dentro de funçao e quer ter um valor padrão, é mt usado o que foi colocado acima: "a = a || 1"

//////////////

'this' pode variar:

this é sempre o objeto que está sendo referenciado naquele contexto de execuçao, q é o dono daquela funçao q ta sendo executado. dependendo, o this pode apontar para outra coisa.

function f1() { console.log(this === window)}
f1(); // vai mostrar true.

// o this pode variar, ali de fato o this aponta pro objeto global q é o window, mas se eu chamar ela a partir de um click em qualquer elemento na pagina e mesmo a pagina vazia, ele vai disparar a chamada a função f1. quando eu disparar a função a partir do click do mouse, o 'this' no contexto já não será mais objeto global.
vejamos este teste:
document.getElementsByTagName('body')[0].onclick = f1; // chamei o primeiro elemento, q é [0], pois quando voce pega getelementsbytagname, mesmo q vc passe uma tag q tenha um elemento, no caso é esperado q tenha uma pagina com um unico body. no caso vai retornar array e vamos pegar o elemento de indice 0, no caso, o primeiro body de uma determinada página, mas é esperado q tenha apenas um body. ao dar enter, e ao clicar na pagina, verá tá chamando a função e AGORA, imprimindo 'false', pois 'this' varia de acordo com a forma como voce chama a função.

// se eu repetir, criando uma função f2, mas agora, em vez de 'this === window' e sim 'this === document', vai dar false também.

// AGORA.... SE EU GUARDAR DENTRO DE UMA CONSTANTE QUALQUER, CHAMADA 'BODY' (chamei disso)
const body = document.getElementsByTagName('body')[0]

// Agora, vou verificar se é igual ao body:
function f2() { console.log(this === body) }

document.getElementsByTagName('body')[0].onclick = f2;
// clico na pagina agora, verá q vai dar 'true'. nesse caso, quem representa o this quando chamo f2, é o proprio elemento q to clicando.

// mas, se eu chamar f2 diretamente, verá que não é o body que tá apontando pro this, e sim o objeto window, pois dará false();
f2(); // dará false

// com Função Arrow:
const f3 = () => console.log(this === window);
f3(); // dará true

// um grande motivo de ter funçao arrow, é que o 'this' não varia. veja:
f3(); // vai dar true
// mas, se eu chamar a partir do clique:
document.getElementsByTagName('body')[0].onclick = f3;
// ao clicar na pagina, vai dar 'true' também.

mas, ao ter funçao normal deu false... pq? pois qd vc tem funçao com a palavra function, o this pode variar de acordo com quem chamou a função. então, o this pode variar. o this representa window? depende de como chamou a funçao. representa o elemento q cliquei? depende de como vc chamou a função. MAS, se for definido como FUNÇÃO ARROW, ele não varia NUNCA.

----> Se a função for definida como FUNÇÃO ARROW, o 'this' não varia NUNCA. com onclick é true, com window é true, etc.

///////////////

this e a função 'bind' 
const pessoa = { 
    saudacao: 'Olá, bom dia',
    falar(){ // voce pode criar um metodo assim também, sem definir function etc
        console.log(this.saudacao); // to acessando o objeto do qual é o dono dessa função, no caso aqui, é o objeto 'pessoa'. sem o 'this' nao vai dar certo.
    }
}

pessoa.falar(); // vai mostrar 'Olá, bom dia'.

// vou armazenar agora essa função 'falar' em uma variável, vai dar um conflito no caso
const falar = pessoa.falar;
falar(); // vai dar undefined, o fato de eu armazenar uma função numa variavel, nesse contexto não to chamando a função 'falar' a  partir do contexto 'pessoa'. 'falar' aqui tá dentro de outro contexto. há conflito entre paradigmas: funcional e OO

// agora, veja:
const falarDePessoa = pessoa.falar.bind(); // o bind voce passa um objeto que voce quer q seja resolvido o 'this'. quem é o this dentro da função 'falar'? o 'this' é a constante 'pessoa'.
falarDePessoa(); // agora vai apontar para o objeto certo. no caso, o 'BIND' é responsavel por amarrar um objeto, pra ele ser o dono da execuçao do metodo. qd chamar a funçao, qd referenciar o this, o this será o objeto q voce passou pra funçao 'bind'

// agora, veja
function Pessoa()
{
    this.idade = 0; // no momento q eu instanciar essa funçao, criar um objeto a partir dessa funçao, vou ter o atributo idade para q eu possa manipular ele.
    setInterval(function(){
        this.idade++;
        console.log(this.idade);
    }, 1000); // essa função dispara outra funçao a partir de um determinado intervalo q vc passou. e voce pode inclusive passar dentro dos parametros uma funçao anonima, q é oq fizemos. o 'setinterval', alem de receber uma funçao, ele tb recebe um intervalo q no caso colocamos '1000' (em ms). a cada 1000 milisegundos, tal funçao vai ser disparada. para q tudo funcione, vou instanciar um objeto de 'Pessoa'. nao se esqueça o 'this' pode variar e ele varia de acordo com quem ta invocando essa função. quem ta invocando a funçao nao sou eu, eu passei a funçao pro 'setInterval'
}

new Pessoa; // ao compilar, vai dar só 'NaN'. ai vc ve q o 'this.idade' não aponta pro objeto pessoa, pois quem ta disparando a chamada dessa funçao é um temporizador e nao o objeto Pessoa. pra resolver, faremos:

function Pessoa()
{
    this.idade = 0; // no momento q eu instanciar essa funçao, criar um objeto a partir dessa funçao, vou ter o atributo idade para q eu possa manipular ele.
    setInterval(function(){
        this.idade++;
        console.log(this.idade);
    }.bind(this), 1000); // uma funçao pode chamar outras funçoes, chamamos 'bind' como notaçao ponto e, dentro, passamos 'this' pra amarrar o this do objeto a chamada da funçao.
}

// agora, faremos:
function Pessoa()
{
    this.idade = 0; 
    const self = this // self recebe a referência de 'this'. como essa linha ta sendo executado dentro do objeto 'Pessoa', significa que nessa linha 'This' é o objeto que eu quero realmente apontar, que é a instancia atual que foi criada lá embaixo com 'new Pessoa'. e com isso, posso substituir 'this' por 'self'. é uma forma de 'driblar' o fato de 'this' variar, criando uma constante e essa constante ficar dentro da funçao. no caso, o 'self' sempre vai apontar pra pessoa.
    setInterval(function(){
        self.idade++; // como ve, substituimos 'this' por 'self'
        console.log(self.idade);
    }/*.bind(this)*/, 1000); 
}

new Pessoa();

// então, vemos q podemos usar o bind ou usar o 'self = this'.

//////////

Função arrow -> o 'this' não varia.

let dobro = function(a)
{
    return 2 * a;
}

/\ reescrevendo em arrow:
let dobro = (a) => 2 * a; 
ou
let dobro = a => { // posso tirar os parenteses de 'a' pq só tenho um parametro
    return 2 * a;
}

console.log(dobro(Math.PI));

ola = () => "Olá"; // funçao sem parametros
console.log(ola);

// posso tbm usar 'underline', q eu to passando na vdd um unico parametro, mas na hr de passar parametro, vc pode ignorar 
ola = _ => 'Olá'
console.log(ola());

////////////

o 'this' dentro da funçao arrow é um 'this' fixo, o fato de que a funçao for chamada de locais diferentes nao influencia no 'this'

function Pessoa()
{
    this.idade = 0;
    setInterval(() => {
        this.idade++;
        console.log(this.idade);
    }, 1000) // dentro de setInterval, criei uma funçao arrow
}

new Pessoa(); // no caso, o 'this' dentro de uma funçao arrow, tá apontando pra 'pessoa', justamente pq o 'this' não varia pq é uma funçao arrow

////////////////

let comparaComThis = function (param){
    console.log(this === param);
}
comparaComThis(global); // vai dar 'true', ta no contexto do node. no browser seria 'window'

const objNew = {}
comparaComThis = comparaComThis.bind(objNew); // agora botei 'bind', vejamos:
comparaComThis(global); // vai dar 'false', por conta do 'bind'
comparaComThis(objNew); // vai dar 'true', o this aponta pro objeto agora por causa do 'bind'

let comparaComThisArrow = param => console.log(this === param); // o this continuará apontando pro global como uma funçao apontaria? verá que não, pois essa funçao foi definida dentro de um 'modulo' do node, e cada arquivo do node representa um modulo. ou seja, o dono dessa funçao seria o proprio modulo. e como referenciar o modulo atual? o 'Arrow' é mais previsivel, o this aponta pro objeto/modulo corrente.

// seria assim entao:
comparaComThisArrow(module.exports); vai dar true

// this nao é o global em caso de funçao arrow, mas é o module.exports

// e se eu usar 'bind' dentro de uma funçao arrow?
comparaComThisArrow = comparaComThisArrow.bind(objNew);
comparaComThisArrow(objNew); // o this continua apontando pro objeto no qual foi escrito, ele nao vai mudar, mesmo com bind.
comparaComThisArrow(module.exports); // vai dar true.

// Ou seja, o 'this' numa funçao arrow vai apontar pro this no qual a função foi escrita, mesmo com o bind nesse caso.


/////////

Funções anonimas -
função sem nome:
const soma = function (x,y) { // uma constante recebeu uma funçao anonima
    return x + y;
}


const imprimirResultado = function (a,b, operacao = soma) { // 'operacao' vai assumir o valor default (soma)
    console.log(operacao(a,b))
}
imprimirResultado(3,4); // 3 e 4 foi para 'x e y' da funçao soma. vai retornar '7'
imprimirResultado(3,4, soma); // vai dar em nada, mas vai retornar 7 também.
imprimirResultado(3,4, function(x, y) { 
    return x - y
}); // o terceiro parametro é uma funçao, passei uma funçao como parametro. vai dar como resultado '-1'
imprimirResultado(3,4, (x,y) => x * y); // vai mostrar como resultado '12', passando como terceiro parametro uma arrow function

// outro exemplo de funçao anonima é criar a funçao dentro de outro objeto
const pessoa = {
    falar: function() {
        console.log('Bom dia');
    }
}
pessoa.falar();

// veja acima q na verdade coloquei uma funçao anonima no atributo 'falar' dentro do objeto 'passar'
podemos deixar assim tbm, tirando o 'function':
falar()
{
    console.log('Opa');
}

//////////

Callback:
significa 'chamar de volta'

const fabricantes = ['Mercedes', 'Audi', 'BMW'];

function imprimir(nome, indice)
{
    console.log(`${indice + 1}. ${nome}`);
}

// a ideia do callback é voce passar uma funçao para outra funçao e quando um determinado evento acontecer, essa funçao vai ser chamada de volta. callback pode ser chamada varias vezes se quiser.

// forEach é uma funçao de fabricantes, e fabricantes é um array. pra cada elemento do array, quero que chame a funçao 'imprimir'. e o 'forEach' vai passar como parametro pra essa funçao o nome do elemento q ele ta percorrendo e, como 2 parametro, o indice.

// pra cada elemento q ele encontrar dentro do array, ele vai chamar de volta pra cada elemento q for encontrado, e vai imprimir no console indice e nome
fabricantes.forEach(imprimir);

// eu poderia fazer:
fabricantes.forEach(function(fabricante){
    console.log(fabricante); // passei como parametro uma funçao q tem como parametro 'a'. quem é o valor de 'a' nessa funçao aqui? 
})

// tbm posso fazer com funçao arrow:
fabricantes.forEach(fabricante => console.log(fabricante)) // é uma funçao 'fabricante' que retorna console.log

// veja então que o callback é nada mais do que passar uma funçao e essa funçao ser chamada quando um evento acontecer. no caso acima, qual evento q aconteceu? o evento é o loop, quando encontra um novo elemento ele dispara um evento q é a funçao q vc chamou. p/ cada elemento ele chama um callback passando o nome e indice. vc passa a funçao e ela chama de volta. outro ex é com requisiçao ajax.

/////////

Funçoes callback #2
const notas = [7.7, 6.5, 5.2, 8.0, 3.6, 7.1, 9.0];

// e se eu gerasse outro array com somente as notas abaixo de 7? vejamos primeiro normal e depois com callback

//Sem Callback
let notasBaixas = [];
for(let i in notas)
{
    if(notas[i] < 7)
    {
        notasBaixas.push(notas[i]);
    }
}

console.log(notasBaixas);

// com Callback:

const notasBaixas2 = notas.filter(function (nota){
    return nota < 7;
}); // filter é uma função que vai filtrar os elementos de um array em cima de um determinado critério e vai retornar true ou false. se a funçao retornar true, significa que ela deve ser chamada no array q esta sendo gerado. se retornar false, ela não vai ser adicionada no array q é a resposta dessa funçao. quando eu chamo 'filter', o resultado da funçao 'notas' vai ser outro array (notasBaixas). o array original "notas" não altera, mas o array 'notasBaixas' sim vai ser alterado. passei uma funçao/callback que o resultado vai ser verdadeiro ou falso, essa funçao recebe como parametro uma nota. 'return nota < 7' vai ser true ou false. se nota < 7, é true, o elemento constará no array final (notasBaixas), senão, não vai adicionar.

// /\ note acima que chamei apenas um callback, uma funçao q sera pra cada um dos elementos


console.log(notasBaixas2);

// Com função arrow:
const notasBaixas3 = notas.filter(nota => nota < 7); // passei uma callback pra esse filter, q recebe como parametro o elemento atual nota e retorna true or false.
console.log(notasBaixas3);

// /\ posso colocar acima em uma constante
const notasMenorQue7 = nota => nota < 7;
const notasBaixas3 = notas.filter(notasMenorQue7);
console.log(notasBaixas3);

/////////////////

Callback #3:
// Exemplo de call back no browser
document.getElementsByTagName('body')[0].onclick = function(e) {
    console.log('O evento ocorreu');
}
// document é a referência dentro do browser q é disponivel globalmente que aponta para sua página. getlementsbytagname acessa os elementos a partir de uma tag. vai retornar vários elementos. a tag que eu quero é o 'body'. e a resposta dessa função é um array. então, pra acessar um elemento especificamente tenho q passar um indice do array. como só tem um body 99% das vezes nas páginas, usamos o array de indice [0]. associado a esse elemento coloco o 'onclick' e vou atribuir ao onclick uma callback para que sempre q o usuario clicar no body. onclick recebe uma funçao, essa funçao recebe como parametro um evento (e).

// ao clicar, a funçao foi registrada, ao clicar, o evento ocorreu. ao clicar, a callback será chamada. ao dar F5, ele não tá mais registrado, tem q registrar novamente (document[....])

////////////

Funções construtoras:
function Carro(velocidadeMaxima = 200, delta = 5)
{
    // atributo privado
    let velocidadeAtual = 0; // atributo que pertence apenas ao escopo da função Carro. quando eu instanciar um objeto a partir dessa funçao, nao tem como acessar diretamente velocidadeAtual pq é um atributo interno da minha função.

    // metodo publico
    this.acelerar = function() { // essa funçao é responsavel por acrescentar a velocidade atual q é uma velocidade q tá visivel apenas naão
        if(velocidadeAtual + delta <= velocidadeMaxima)
        {
            velocidadeAtual += delta;
        }
        else{
            velocidadeAtual = velocidadeMaxima;
        }
    }

    // método público
    this.getVelocidadeAtual = function() {
        return velocidadeAtual;
    }// método responsável por pegar a velocidade atual. eu poderia deixar 'velocidadeAtual' aberta, mas ai o usuário pegaria um valor maior q 
    a velocidade maxima e voce nao teria controle dessa variavel. entao vc pode permitir acesso a variável através de uma funçaõ com getVelocidadeAtual e vc retorna o valor da velocidade atual q é um atributo privado (atributo privado cria-se com let, var ou const).  
}

const uno = new Carro(); // instanciando um objeto
uno.acelerar();
console.log(uno.getVelocidadeAtual());

// se quiser que algo seja publico, pra ser visivel fora da funçao construtora, vc usa o 'this'.

const ferrari = new Carro(350, 20);
ferrari.acelerar();
console.log(ferrari.getVelocidadeAtual());

//////////////////////

Tipos de declaração de função -

// function declaration
function soma (x,y) // a vantagem de usar esse tipo de declaraçao, é q posso chamar ela antes de ela ser declarada.
{
    return x + y;
}

// function expression
const sub = function (x,y)
{
    return x - y;
}

// named function expression
const mult = function mult(x,y){ // mais util somente para debugar
    return x * y;
}

//////////

Contexto léxico -
// contexto no qual as coisas são declaradas dentro da linguagem

const valor = 'Global';

function minhaFuncao()
{
    console.log(valor);
}

function exec(){
    const valor = 'Local';
    minhaFuncao(); // ao chamar essa funçao aq, vai mostrar 'Global' ou 'Local'? Dentro do contexto lexico, vai mostrar 'Global', pq? a funçao carrega consigo o contexto lexico, ela vai procurar dentro do contexto lexico na qual foi definida, por isso mostra 'Global'
}

exec();

///////////////////

// Closure
Closure é o escopo criado quando uma função é declarada.
// Esse escopo permite a função acessar e manipular variáveis externas à função

const x = 'Global';

function fora() {
    const x = 'Local';
    function dentro() {
        return x;
    }
    return dentro;
}
const minhaFuncao = fora();
console.log(minhaFuncao()); // qual valor de 'x' q ela retorna? o valor de 'x' global ou o valor de 'x' local? por conta de uma funçao em javascript ser um closure, ele terá ciencia de onde foi definida e acessará a variavel 'x' local e nao a global.

///////////

Funções Factory - é uma função que retorna um objeto

// Imaginemos

const prod1 = {
    nome: '...', // nome do produto
    preco: 45
}

const prod2 = { // outro produto exatamente igual ao prod1
    nome: '....',
    preco: 1234
}

// se voce for fazendo esse processo muitas vezes, voce repete demais o conteudo de um determinado objeto no programa

// Factory Simples:
function criarPessoa(){
    return{ // dentro da função to retornando um objeto
        nome: 'Ana',
        sobrenome: 'Silva'
    }
}

// factory entao é uma funçao que sempre retorna um objeto, embora aqui nao tenha o operador 'new', o fato de estar criando um objeto a partir da notaçao literal de objeto ( { } ), voce ta sempre criando uma nova instancia de pessoa. pode simplesmente criar um objeto a partir da chamada da funçao. 

console.log(criarPessoa()); // portanto, tenho aqui a criaçao de uma pessoa a partir de uma factory. por isso o nome 'factory', que ela tem a funçao de fabricar a instancia de um objeto

////////////

Factory #2 :

function criarProduto(nomeProduto, precoProduto)
{
    return{
        nomeProduto,
        precoProduto,
        desconto: 0.1
    }
}

console.log(criarProduto('Notebook', 2199.49));
console.log(criarProduto('iPad', 1199.49));

// /\ funçao factory exemplo, so que com o desconto de 10% fixo como padrão. nao precisei coloquei nome:nomeProduto, pois é o nome que eu quis. 

///////////

Classe x Funçao Factory:
class Pessoa {
    constructor(nome) { // aqui tenho o construtor dessa classe para inicializar variaveis que porventura passemos na hora da construção
        this.nome = nome; // assim que coloquei aqui this.nome , significa que essa variavel 'nome' passou a ser publica, entao vou poder ter acesso a ela sempre q eu quiser a partir da instancia dessa classe.
    }

    falar() {
        console.log(`Meu nome é ${this.nome}`);
    }
}

const p1 = new Pessoa('João'); // passei aqui string, q foi passada pro construtor
p1.falar();

// vai mostrar o esperado, meu nome é joão

const pessoa = nome => {
    return {
        falar: () => console.log(`Meu nome é ${nome}`); // com Factory aqui, eu nao preciso usar o 'this', pq ele tem consciencia do contexto lexico no qual foi declarado.
    }
}

const p2 = pessoa('João');
p2.falar();

///////////

Transformar este codigo em uma função construtora:
class Pessoa {
    constructor(nome) { // aqui tenho o construtor dessa classe para inicializar variaveis que porventura passemos na hora da construção
        this.nome = nome; // assim que coloquei aqui this.nome , significa que essa variavel 'nome' passou a ser publica, entao vou poder ter acesso a ela sempre q eu quiser a partir da instancia dessa classe.
    }

    falar() {
        console.log(`Meu nome é ${this.nome}`);
    }
}

---------

// os parametros do construtor vao passar a ser parametro dessa funçao a ser criada. o que voce fez dentro do 'constructor', agora, vc faz dentro direto da sua funçao construtora

function Pessoa(nome) {

    this.nome = nome; 

    this.falar = function() { // e para transformar essa funçao pra ficar diretamente no objeto, fiz assim 'this.falar = function()'
        console.log(`Meu nome é ${this.nome}`);
    }
}

const p1 = new Pessoa('João');
p1.falar(); // aqui a instanciação é a mesma

// entao posso criar objeto a partir de uma funçao construtora, de uma classe e criar objeto a partir de uma factory

///////////

IIFE - Função auto invocada, na declaraçao da funçao ja invoca a execuçao da função. ideal pra fugir do escopo global. tudo que voce criar na função será escopo local da função e não escopo global da função. evita manipular algo no escopo global. aqui, voce foge do escopo global, criando função autoinvocada.

(function(){ // criei uma funçao anonima
    console.log("Será executado na hora");
    console.log("Foge do escopo mais abrangente!");
})() // pra finalizar, no final, preciso chamar ele com os ()


//////////

Call & Apply -

function getPreco(imposto = 0, moeda = 'R$')
{
    return `${moeda} ${this.preco * (1 - this.desc) * (1 + imposto)}`;
}

const produto = {
    nome: 'notebook',
    preco: 4589,
    desc: 0.15,
    getPreco // como ja tenho uma funçao com esse nome, ao criar um atributo assim com esse nome ele ja vai associar automaticamente a funçao
}

// se eu fizesse assim:
// global.preco = 18;
// global.desc = 2; 
// funcionaria, pq teria definido globalmente
console.log(getPreco()); // vai dar NaN pq simplesmente nao defini preco e desconto, a nao ser se eu fizesse o que fiz acima, declarando como 'global.preco = 18 e global.desc = 2'
console.log(produto.getPreco()); // outra forma: agora funciona normalmente, pq chamei 'getpreco' a partir de um objeto

// outra forma é a partir do call e apply:

const carro = { preco: 49990, desc: 0.20}; // criei outro objeto
// a partir desse objeto, vou chamar getPreco
console.log(getPreco.call(carro)); // passei como contexto o objeto carro pro valor da execução
console.log(getPreco.apply(carro)); 

// qual a diferença de call e apply? é a chamada nos parametros.
com call, eu passo diretamente eu passo os parametros cada um dos parametros que serao passado da funçao. o 1 parametro sempre é o contexto.
ex:
console.log(getPreco.call(carro, 0.17, '$'));

// com apply, vou passar os parametros dentro de um array
console.log(getPreco.apply(carro, [0.17, '$']));

o contexto poderia ser 'global' tb, ai usaria o global que passamos lá em cima:
console.log(getPreco.apply(global, [0.17, '$']));
console.log(getPreco.call(global, 0.17, '$'));