function teste2(nota)
{
    if(nota > 7) // sim, isto é uma sentença de codigo
        ;

    {
        console.log(nota);
    }
}

// o ; ali é uma instrução vazia. então, console.log(nota) sempre será impresso, não tem condiçao pra isso.

const imprimirResultado = function teste2(nota)
{
    if(nota >= 7)
    {
        console.log('Aprovado');
    }
    else
    {
        console.log('Reprovado');
    }
}

imprimirResultado('Epa'); // vai ser false, vai imprimir 'reprovado', por falha do javascript, q é uma linguagem fracamente tipada

Number.prototype.entre = function (inicio, fim)
{
    return this >= inicio&& this <= fim
}

const imprimirResultado = function (nota)
{
    if(nota.entre(9,10))
    {
        console.log('Quadro de Honra');
    }
    else if (nota.entre(7, 8.99))
    {
        console.log('Aprovado');
    }
    else if (nota.entre(4, 6.99))
    {
        console.log('Recuperação');
    }
    else if (nota.entre(70, 3.99))
    {
        console.log('Reprovado');
    }
}

imprimirResultado(8.5);
imprimirResultado(5);

---
com switch: melhor pra necessidades multiplas

const imprimirResultado = function (nota)
{
    switch(Math.floor(nota)){
        case 10:
        case 9:
            console.log('Quadro de Honra');
        case 8: case 7:
            console.log('Aprovado');
        case 6: case 5: case 4:
            console.log('Recuperação');
        case 3: case 2: case 1:
            console.log('Reprovado');
        default:
            console.log("Nota inválida");
    }
}

imprimirResultado(4);


////////// 

- WHILE:

function getInteiroAleatorioEntre(min, max)
{
    const valor = Math.random() * (max-min) + min
    return Math.floor(valor);
}

let opcao = -1;

// enquanto a expressão for verdadeira, continue executando o laço até q seja falso
while (opcao != -1)
{
    opcao = getInteiroAleatorioEntre(-1, 10); // o valor tá sendo alterado pela função
    console.log('A opção escolhida foi `${opcao}`');
}

// ele tá sempre sorteando, até q saia um -1.

//////////////////////////////

const notas = [6.5, 7.5, 9.0, 3.2, 4.1];

for(let i = 0; i < notas.length; i++)
{
    console.log(`A nota agora é: ${notas[i]}`);
}

///////////////////

FOR IN:
const notas = [6.7, 7.4, 8.3, 7.7];

// o FOR IN vai te dar os indices do elemento, como se fosse te dar os atributos de um array (ex.: o 1 elemento do array é 0, o 2 elemento do arary é 1). foreach é melhor.

for (let i in notas) // para cada um dos elementos de notas vai te devolver um indice 'i'. bom usar 'let' para garantir que 'i' estará apenas naquele laço, isto é, variavel local daquele laço, presente apenas neste escopo.
{
    console.log(i, notas[i]); // vai mostrar os indices e o que há dentro de cada índice
} 



-- Outro exemplo:

const pessoa = {
    nome: 'Gustavo',
    sobrenome: 'Marcon',
    idade: 20,
    peso: 60
}

for(let atributo in pessoa)
{
    console.log(`${atributo} : ${pessoaNova[atributo]}`);
}

///////////////

Usando break e continue:

const nums = [1,2,3,4,5,6,7,8,9,10];

for (x in nums){
    if (x==5) break;
    console.log(`x = ${nums[x]}`);
}

for (y in nums)
{
    if (y==5) continue; // 'continue' simplesmente interrompe a repetição corrente e vai para a proxima repetição
    console.log(`${y} = ${nums[y]}`);
}

// Agora com pares:
externo: for (a in nums) // atr
{
    for(b in nums)
    {
        if(a == 2 && b == 3) break externo
        console.log(`Par = ${a}, ${b}`);
    }
}

/\ criei um rotulo chamado 'externo', e esse rotulo fica associado a um laço 'for'. dentro deste for, criei um outro for q teoricamente seria um for interno, onde 'a' sempre o indice de nums, e b sendo indice de nums também. se eu não tivesse colocado 'break externo', e sim apenas 'break', ele iria chamar apenas o break do for "interno" (q é o b in nums), pq é o laço mais proximo do break. se eu quiser criar um break mais externo, so a partir de um rotulo, por isso tenho o 'externo'.

/\ Isso já nem é mais muito utilizado, melhor quebrar em métodos, foreach, etc.


--------------

Função:
// Criar de forma literal
function func1() { } // toda função retorna ao menos algum valor. se não definir o retorno, ele retorna ao menos undefined. o bloco em função é obrigatorio

// Armazenar em uma variável:
const fun2 = function () { }

// Armazenar em um array:
const array = [function (a,b) { return a + b }, fun1, fun2]; // posso armazenar criando uma funçao anonima direto, ou criar uma funçao armazenando em uma variavel e colocar esta variavel no array

console.log(array[0](2,3)); // chamei ali o array de indice 0, q é uma funçao e, a essa funçao, passei os parametros '2' e '3'

// Armazenando em um atributo de objeto:
const obj = {}; // aqui criei um objeto, lembre-se, {} define objeto

obj.falar = function () { return 'Opa' };

console.log(obj.falar()); // tem q colocar os parenteses () para de fato invocar a função

// Passar função como parametro para outra função:
function run (fun) // criei uma função chamada run, recebe como parametro 'fun' ( espero receber como parametro uma função)
{
    fun(); // executando uma função, graças ao o que ta entre parenteses.
}

run(function () { console.log('Executando....') }); // chamei e passei como parametro uma função. aqui, não to executando uma função, apenas em fun(), dentro da função fun.

// Além de conseguir passar como parametro, tbm é possivel retornar uma função como parametro.

// Uma função pode retornar/conter uma/outra função
function soma(a,b) {
    return function(c) {
        console.log(a+b+c);
    }
}

soma(2,3)(4); // é uma forma de fazer chamando a função soma e depois já chamar diretamente a outra função. passei primeiro o parametro de 'soma' e depois o parametro da funçao q ta retornando a tal função. o resultado aí será 9.

const cincoMais = soma(2,3); // mas tb posso armazenar o resultado dessa variável em uma constante/variável e depois usar essa constante/variável pra continuar a chamada da função
cincoMais(4);

////////////

- Parâmetros e retorno são opcionais
function area(largura, altura)
{
    const area = largura * altura;
    if(area > 20)
    {
        console.log(`Valor acima do permitido: ${area}m2`);
    }
    else
    {
        return area
    }
}

console.log(area(2,2)); // vai executar normalmente
console.log(area(2)); // vai dar NaN, pq simplesmente não tem o 2 parametro.
console.log(area()); // só dá NaN
console.log(area(2,3,17,22,44)); // vai ler apenas os 2 primeiros e vai ignorar o resto 
 
////////////////

Parametros variáveis -
function soma() // o fato de não receber nenhum parametro não significa que não se pode passar nenhum parametro, mas pode passar parametro sim, e dentro da função recuperar esses parametros a partir de uma propriedade chamada arguments
{
    let soma = 0;
    for (i in arguments) // arguments é um array, e com 'i' vou pegar o indice de cada elemento do array. posso pegar cada um dos elementos e ir somando a variavel soma. arguments é o array interno de uma função que tem todos os argumentos q foram passados.
    { 
        soma += arguments[i];
    }
    return soma; // aq é o resultado de todas as somas q passei
}
console.log(soma()); // resulta '0', é a soma total
console.log(soma(1)); // resulta em 1
console.log(soma(1.1, 2.2, 3.3)); // resulta em 6.6, soma de tudo
// ele não se limita apenas a numero, claro, se vc der:
console.log(soma(1.1, 2.2, "testeeweee")); // vai resultar na soma de 1.1 com 2.2 e juntar com 'testeeweeee'

// ---> tem outros operadores, como o rest, veremos pra frente

-----------------

parametro padrão-
function soma1(a,b,c) // vc vai receber valor a, b e c de uma soma
{
    a = a || 1; // a vai receber 'a' se for true, se for false ele recebe '1'
    b = b || 1; // a vai receber 'a' se for true, se for false ele recebe '1'
    c = c || 1;
    return a + b + c; // com ctz ele não vai ser um valor nulo ou undefined, pq se for false, recebe '1' como valor
}
console.log(soma1(), soma1(1,2,3), soma1(0,0,0)); // primeiro vai retornar '3' (pq é a soma de 1+1+1). depois, vai retornar 5. dps, mesmo passando '0,0,0', ele vai retornar '3', pq '0' é sempre false, então ele gera '1' [daí a soma de cada um pra dar 3].


// outras estratégias pra gerar um valor padrão
function soma2(a,b,c)
{
    a = a !== undefined ? a : 1; // 1º estratégia: a vai receber o seguinte: se a for diferente de undefined (se tiver algum valor), ela recebe o valor de 'a', q foi dado no parametro, senão, recebe como padrão o valor '1'.
    b = 1 in arguments? b : 1; // 2º estrategia - dentro de 'arguments' existe o valor 1? se existir, b pega o valor de b, senão, pega o valor '1' como padrão. aqui é '1 in arguments' pq 'b' é de indice '1', se fosse 'a' seria '0 in arguments? [...]'
    c = isNaN(c) ? 1 : c; // essa é a estrategia mais segura para valores numericos.
    return a + b + c;
}
console.log(soma2(1,2,3)); // soma todos normalmente
console.log(soma2()); // vai mostrar '3', pq recebeu valor padra
console.log(soma2(1)); // vai mostrar '3', mas recebeu o primeiro parametro (a) mas caiu em true, b e c receberam 1 como valor padrão pq cairam em false
console.log(soma2(5,6)); // vai mostrar '12', pq a e b tão em true, fizeram soma, mas c tá em false e caiu como valor padrão '1'.
console.log(soma2(5,6,"Olá")); // mesma coisa do de cima.

// MAS, tem a melhor forma como valor numerico:
function soma3(a = 1, b = 1, c = 1)
{
    return a + b + c;
}
console.log(soma3(), soma3(3), soma3(1,2,3), soma3(0,0,0)); // vai sempre receber '1' como padrão caso não definido

// o valor padrao acima de funçao é pra colocar em parametros de funçao, mas se tiver criado variavel dentro de funçao e quer ter um valor padrão, é mt usado o que foi colocado acima: "a = a || 1"

//////////////

'this' pode variar:

this é sempre o objeto que está sendo referenciado naquele contexto de execuçao, q é o dono daquela funçao q ta sendo executado. dependendo, o this pode apontar para outra coisa.

function f1() { console.log(this === window)}
f1(); // vai mostrar true.

// o this pode variar, ali de fato o this aponta pro objeto global q é o window, mas se eu chamar ela a partir de um click em qualquer elemento na pagina e mesmo a pagina vazia, ele vai disparar a chamada a função f1. quando eu disparar a função a partir do click do mouse, o 'this' no contexto já não será mais objeto global.
vejamos este teste:
document.getElementsByTagName('body')[0].onclick = f1; // chamei o primeiro elemento, q é [0], pois quando voce pega getelementsbytagname, mesmo q vc passe uma tag q tenha um elemento, no caso é esperado q tenha uma pagina com um unico body. no caso vai retornar array e vamos pegar o elemento de indice 0, no caso, o primeiro body de uma determinada página, mas é esperado q tenha apenas um body. ao dar enter, e ao clicar na pagina, verá tá chamando a função e AGORA, imprimindo 'false', pois 'this' varia de acordo com a forma como voce chama a função.

// se eu repetir, criando uma função f2, mas agora, em vez de 'this === window' e sim 'this === document', vai dar false também.

// AGORA.... SE EU GUARDAR DENTRO DE UMA CONSTANTE QUALQUER, CHAMADA 'BODY' (chamei disso)
const body = document.getElementsByTagName('body')[0]

// Agora, vou verificar se é igual ao body:
function f2() { console.log(this === body) }

document.getElementsByTagName('body')[0].onclick = f2;
// clico na pagina agora, verá q vai dar 'true'. nesse caso, quem representa o this quando chamo f2, é o proprio elemento q to clicando.

// mas, se eu chamar f2 diretamente, verá que não é o body que tá apontando pro this, e sim o objeto window, pois dará false();
f2(); // dará false

// com Função Arrow:
const f3 = () => console.log(this === window);
f3(); // dará true

// um grande motivo de ter funçao arrow, é que o 'this' não varia. veja:
f3(); // vai dar true
// mas, se eu chamar a partir do clique:
document.getElementsByTagName('body')[0].onclick = f3;
// ao clicar na pagina, vai dar 'true' também.

mas, ao ter funçao normal deu false... pq? pois qd vc tem funçao com a palavra function, o this pode variar de acordo com quem chamou a função. então, o this pode variar. o this representa window? depende de como chamou a funçao. representa o elemento q cliquei? depende de como vc chamou a função. MAS, se for definido como FUNÇÃO ARROW, ele não varia NUNCA.

----> Se a função for definida como FUNÇÃO ARROW, o 'this' não varia NUNCA. com onclick é true, com window é true, etc.

///////////////

this e a função 'bind' 
const pessoa = { 
    saudacao: 'Olá, bom dia',
    falar(){ // voce pode criar um metodo assim também, sem definir function etc
        console.log(this.saudacao); // to acessando o objeto do qual é o dono dessa função, no caso aqui, é o objeto 'pessoa'. sem o 'this' nao vai dar certo.
    }
}

pessoa.falar(); // vai mostrar 'Olá, bom dia'.

// vou armazenar agora essa função 'falar' em uma variável, vai dar um conflito no caso
const falar = pessoa.falar;
falar(); // vai dar undefined, o fato de eu armazenar uma função numa variavel, nesse contexto não to chamando a função 'falar' a  partir do contexto 'pessoa'. 'falar' aqui tá dentro de outro contexto. há conflito entre paradigmas: funcional e OO

// agora, veja:
const falarDePessoa = pessoa.falar.bind(); // o bind voce passa um objeto que voce quer q seja resolvido o 'this'. quem é o this dentro da função 'falar'? o 'this' é a constante 'pessoa'.
falarDePessoa(); // agora vai apontar para o objeto certo. no caso, o 'BIND' é responsavel por amarrar um objeto, pra ele ser o dono da execuçao do metodo. qd chamar a funçao, qd referenciar o this, o this será o objeto q voce passou pra funçao 'bind'

// agora, veja
function Pessoa()
{
    this.idade = 0; // no momento q eu instanciar essa funçao, criar um objeto a partir dessa funçao, vou ter o atributo idade para q eu possa manipular ele.
    setInterval(function(){
        this.idade++;
        console.log(this.idade);
    }, 1000); // essa função dispara outra funçao a partir de um determinado intervalo q vc passou. e voce pode inclusive passar dentro dos parametros uma funçao anonima, q é oq fizemos. o 'setinterval', alem de receber uma funçao, ele tb recebe um intervalo q no caso colocamos '1000' (em ms). a cada 1000 milisegundos, tal funçao vai ser disparada. para q tudo funcione, vou instanciar um objeto de 'Pessoa'. nao se esqueça o 'this' pode variar e ele varia de acordo com quem ta invocando essa função. quem ta invocando a funçao nao sou eu, eu passei a funçao pro 'setInterval'
}

new Pessoa; // ao compilar, vai dar só 'NaN'. ai vc ve q o 'this.idade' não aponta pro objeto pessoa, pois quem ta disparando a chamada dessa funçao é um temporizador e nao o objeto Pessoa. pra resolver, faremos:

function Pessoa()
{
    this.idade = 0; // no momento q eu instanciar essa funçao, criar um objeto a partir dessa funçao, vou ter o atributo idade para q eu possa manipular ele.
    setInterval(function(){
        this.idade++;
        console.log(this.idade);
    }.bind(this), 1000); // uma funçao pode chamar outras funçoes, chamamos 'bind' como notaçao ponto e, dentro, passamos 'this' pra amarrar o this do objeto a chamada da funçao.
}

// agora, faremos:
function Pessoa()
{
    this.idade = 0; 
    const self = this // self recebe a referência de 'this'. como essa linha ta sendo executado dentro do objeto 'Pessoa', significa que nessa linha 'This' é o objeto que eu quero realmente apontar, que é a instancia atual que foi criada lá embaixo com 'new Pessoa'. e com isso, posso substituir 'this' por 'self'. é uma forma de 'driblar' o fato de 'this' variar, criando uma constante e essa constante ficar dentro da funçao. no caso, o 'self' sempre vai apontar pra pessoa.
    setInterval(function(){
        self.idade++; // como ve, substituimos 'this' por 'self'
        console.log(self.idade);
    }/*.bind(this)*/, 1000); 
}

new Pessoa();

// então, vemos q podemos usar o bind ou usar o 'self = this'.

//////////

Função arrow -> o 'this' não varia.

let dobro = function(a)
{
    return 2 * a;
}

/\ reescrevendo em arrow:
let dobro = (a) => 2 * a; 
ou
let dobro = a => { // posso tirar os parenteses de 'a' pq só tenho um parametro
    return 2 * a;
}

console.log(dobro(Math.PI));

ola = () => "Olá"; // funçao sem parametros
console.log(ola);

// posso tbm usar 'underline', q eu to passando na vdd um unico parametro, mas na hr de passar parametro, vc pode ignorar 
ola = _ => 'Olá'
console.log(ola());

////////////

o 'this' dentro da funçao arrow é um 'this' fixo, o fato de que a funçao for chamada de locais diferentes nao influencia no 'this'

function Pessoa()
{
    this.idade = 0;
    setInterval(() => {
        this.idade++;
        console.log(this.idade);
    }, 1000) // dentro de setInterval, criei uma funçao arrow
}

new Pessoa(); // no caso, o 'this' dentro de uma funçao arrow, tá apontando pra 'pessoa', justamente pq o 'this' não varia pq é uma funçao arrow

////////////////

let comparaComThis = function (param){
    console.log(this === param);
}
comparaComThis(global); // vai dar 'true', ta no contexto do node. no browser seria 'window'

const objNew = {}
comparaComThis = comparaComThis.bind(objNew); // agora botei 'bind', vejamos:
comparaComThis(global); // vai dar 'false', por conta do 'bind'
comparaComThis(objNew); // vai dar 'true', o this aponta pro objeto agora por causa do 'bind'

let comparaComThisArrow = param => console.log(this === param); // o this continuará apontando pro global como uma funçao apontaria? verá que não, pois essa funçao foi definida dentro de um 'modulo' do node, e cada arquivo do node representa um modulo. ou seja, o dono dessa funçao seria o proprio modulo. e como referenciar o modulo atual? o 'Arrow' é mais previsivel, o this aponta pro objeto/modulo corrente.

// seria assim entao:
comparaComThisArrow(module.exports); vai dar true

// this nao é o global em caso de funçao arrow, mas é o module.exports

// e se eu usar 'bind' dentro de uma funçao arrow?
comparaComThisArrow = comparaComThisArrow.bind(objNew);
comparaComThisArrow(objNew); // o this continua apontando pro objeto no qual foi escrito, ele nao vai mudar, mesmo com bind.
comparaComThisArrow(module.exports); // vai dar true.

// Ou seja, o 'this' numa funçao arrow vai apontar pro this no qual a função foi escrita, mesmo com o bind nesse caso.


/////////

Funções anonimas -
função sem nome:
const soma = function (x,y) { // uma constante recebeu uma funçao anonima
    return x + y;
}


const imprimirResultado = function (a,b, operacao = soma) { // 'operacao' vai assumir o valor default (soma)
    console.log(operacao(a,b))
}
imprimirResultado(3,4); // 3 e 4 foi para 'x e y' da funçao soma. vai retornar '7'
imprimirResultado(3,4, soma); // vai dar em nada, mas vai retornar 7 também.
imprimirResultado(3,4, function(x, y) { 
    return x - y
}); // o terceiro parametro é uma funçao, passei uma funçao como parametro. vai dar como resultado '-1'
imprimirResultado(3,4, (x,y) => x * y); // vai mostrar como resultado '12', passando como terceiro parametro uma arrow function

// outro exemplo de funçao anonima é criar a funçao dentro de outro objeto
const pessoa = {
    falar: function() {
        console.log('Bom dia');
    }
}
pessoa.falar();

// veja acima q na verdade coloquei uma funçao anonima no atributo 'falar' dentro do objeto 'passar'
podemos deixar assim tbm, tirando o 'function':
falar()
{
    console.log('Opa');
}

//////////

Callback:
significa 'chamar de volta'

const fabricantes = ['Mercedes', 'Audi', 'BMW'];

function imprimir(nome, indice)
{
    console.log(`${indice + 1}. ${nome}`);
}

// a ideia do callback é voce passar uma funçao para outra funçao e quando um determinado evento acontecer, essa funçao vai ser chamada de volta. callback pode ser chamada varias vezes se quiser.

// forEach é uma funçao de fabricantes, e fabricantes é um array. pra cada elemento do array, quero que chame a funçao 'imprimir'. e o 'forEach' vai passar como parametro pra essa funçao o nome do elemento q ele ta percorrendo e, como 2 parametro, o indice.

// pra cada elemento q ele encontrar dentro do array, ele vai chamar de volta pra cada elemento q for encontrado, e vai imprimir no console indice e nome
fabricantes.forEach(imprimir);

// eu poderia fazer:
fabricantes.forEach(function(fabricante){
    console.log(fabricante); // passei como parametro uma funçao q tem como parametro 'a'. quem é o valor de 'a' nessa funçao aqui? 
})

// tbm posso fazer com funçao arrow:
fabricantes.forEach(fabricante => console.log(fabricante)) // é uma funçao 'fabricante' que retorna console.log

// veja então que o callback é nada mais do que passar uma funçao e essa funçao ser chamada quando um evento acontecer. no caso acima, qual evento q aconteceu? o evento é o loop, quando encontra um novo elemento ele dispara um evento q é a funçao q vc chamou. p/ cada elemento ele chama um callback passando o nome e indice. vc passa a funçao e ela chama de volta. outro ex é com requisiçao ajax.

/////////

Funçoes callback #2
const notas = [7.7, 6.5, 5.2, 8.0, 3.6, 7.1, 9.0];

// e se eu gerasse outro array com somente as notas abaixo de 7? vejamos primeiro normal e depois com callback

//Sem Callback
let notasBaixas = [];
for(let i in notas)
{
    if(notas[i] < 7)
    {
        notasBaixas.push(notas[i]);
    }
}

console.log(notasBaixas);

// com Callback:

const notasBaixas2 = notas.filter(function (nota){
    return nota < 7;
}); // filter é uma função que vai filtrar os elementos de um array em cima de um determinado critério e vai retornar true ou false. se a funçao retornar true, significa que ela deve ser chamada no array q esta sendo gerado. se retornar false, ela não vai ser adicionada no array q é a resposta dessa funçao. quando eu chamo 'filter', o resultado da funçao 'notas' vai ser outro array (notasBaixas). o array original "notas" não altera, mas o array 'notasBaixas' sim vai ser alterado. passei uma funçao/callback que o resultado vai ser verdadeiro ou falso, essa funçao recebe como parametro uma nota. 'return nota < 7' vai ser true ou false. se nota < 7, é true, o elemento constará no array final (notasBaixas), senão, não vai adicionar.

// /\ note acima que chamei apenas um callback, uma funçao q sera pra cada um dos elementos


console.log(notasBaixas2);

// Com função arrow:
const notasBaixas3 = notas.filter(nota => nota < 7); // passei uma callback pra esse filter, q recebe como parametro o elemento atual nota e retorna true or false.
console.log(notasBaixas3);

// /\ posso colocar acima em uma constante
const notasMenorQue7 = nota => nota < 7;
const notasBaixas3 = notas.filter(notasMenorQue7);
console.log(notasBaixas3);

/////////////////

Callback #3:
// Exemplo de call back no browser
document.getElementsByTagName('body')[0].onclick = function(e) {
    console.log('O evento ocorreu');
}
// document é a referência dentro do browser q é disponivel globalmente que aponta para sua página. getlementsbytagname acessa os elementos a partir de uma tag. vai retornar vários elementos. a tag que eu quero é o 'body'. e a resposta dessa função é um array. então, pra acessar um elemento especificamente tenho q passar um indice do array. como só tem um body 99% das vezes nas páginas, usamos o array de indice [0]. associado a esse elemento coloco o 'onclick' e vou atribuir ao onclick uma callback para que sempre q o usuario clicar no body. onclick recebe uma funçao, essa funçao recebe como parametro um evento (e).

// ao clicar, a funçao foi registrada, ao clicar, o evento ocorreu. ao clicar, a callback será chamada. ao dar F5, ele não tá mais registrado, tem q registrar novamente (document[....])

////////////

Funções construtoras:
function Carro(velocidadeMaxima = 200, delta = 5)
{
    // atributo privado
    let velocidadeAtual = 0; // atributo que pertence apenas ao escopo da função Carro. quando eu instanciar um objeto a partir dessa funçao, nao tem como acessar diretamente velocidadeAtual pq é um atributo interno da minha função.

    // metodo publico
    this.acelerar = function() { // essa funçao é responsavel por acrescentar a velocidade atual q é uma velocidade q tá visivel apenas naão
        if(velocidadeAtual + delta <= velocidadeMaxima)
        {
            velocidadeAtual += delta;
        }
        else{
            velocidadeAtual = velocidadeMaxima;
        }
    }

    // método público
    this.getVelocidadeAtual = function() {
        return velocidadeAtual;
    }// método responsável por pegar a velocidade atual. eu poderia deixar 'velocidadeAtual' aberta, mas ai o usuário pegaria um valor maior q 
    a velocidade maxima e voce nao teria controle dessa variavel. entao vc pode permitir acesso a variável através de uma funçaõ com getVelocidadeAtual e vc retorna o valor da velocidade atual q é um atributo privado (atributo privado cria-se com let, var ou const).  
}

const uno = new Carro(); // instanciando um objeto
uno.acelerar();
console.log(uno.getVelocidadeAtual());

// se quiser que algo seja publico, pra ser visivel fora da funçao construtora, vc usa o 'this'.

const ferrari = new Carro(350, 20);
ferrari.acelerar();
console.log(ferrari.getVelocidadeAtual());

//////////////////////

Tipos de declaração de função -

// function declaration
function soma (x,y) // a vantagem de usar esse tipo de declaraçao, é q posso chamar ela antes de ela ser declarada.
{
    return x + y;
}

// function expression
const sub = function (x,y)
{
    return x - y;
}

// named function expression
const mult = function mult(x,y){ // mais util somente para debugar
    return x * y;
}

//////////

Contexto léxico -
// contexto no qual as coisas são declaradas dentro da linguagem

const valor = 'Global';

function minhaFuncao()
{
    console.log(valor);
}

function exec(){
    const valor = 'Local';
    minhaFuncao(); // ao chamar essa funçao aq, vai mostrar 'Global' ou 'Local'? Dentro do contexto lexico, vai mostrar 'Global', pq? a funçao carrega consigo o contexto lexico, ela vai procurar dentro do contexto lexico na qual foi definida, por isso mostra 'Global'
}

exec();

///////////////////

// Closure
Closure é o escopo criado quando uma função é declarada.
// Esse escopo permite a função acessar e manipular variáveis externas à função

const x = 'Global';

function fora() {
    const x = 'Local';
    function dentro() {
        return x;
    }
    return dentro;
}
const minhaFuncao = fora();
console.log(minhaFuncao()); // qual valor de 'x' q ela retorna? o valor de 'x' global ou o valor de 'x' local? por conta de uma funçao em javascript ser um closure, ele terá ciencia de onde foi definida e acessará a variavel 'x' local e nao a global.

///////////

Funções Factory - é uma função que retorna um objeto

// Imaginemos

const prod1 = {
    nome: '...', // nome do produto
    preco: 45
}

const prod2 = { // outro produto exatamente igual ao prod1
    nome: '....',
    preco: 1234
}

// se voce for fazendo esse processo muitas vezes, voce repete demais o conteudo de um determinado objeto no programa

// Factory Simples:
function criarPessoa(){
    return{ // dentro da função to retornando um objeto
        nome: 'Ana',
        sobrenome: 'Silva'
    }
}

// factory entao é uma funçao que sempre retorna um objeto, embora aqui nao tenha o operador 'new', o fato de estar criando um objeto a partir da notaçao literal de objeto ( { } ), voce ta sempre criando uma nova instancia de pessoa. pode simplesmente criar um objeto a partir da chamada da funçao. 

console.log(criarPessoa()); // portanto, tenho aqui a criaçao de uma pessoa a partir de uma factory. por isso o nome 'factory', que ela tem a funçao de fabricar a instancia de um objeto

////////////

Factory #2 :

function criarProduto(nomeProduto, precoProduto)
{
    return{
        nomeProduto,
        precoProduto,
        desconto: 0.1
    }
}

console.log(criarProduto('Notebook', 2199.49));
console.log(criarProduto('iPad', 1199.49));

// /\ funçao factory exemplo, so que com o desconto de 10% fixo como padrão. nao precisei coloquei nome:nomeProduto, pois é o nome que eu quis. 

///////////

Classe x Funçao Factory:
class Pessoa {
    constructor(nome) { // aqui tenho o construtor dessa classe para inicializar variaveis que porventura passemos na hora da construção
        this.nome = nome; // assim que coloquei aqui this.nome , significa que essa variavel 'nome' passou a ser publica, entao vou poder ter acesso a ela sempre q eu quiser a partir da instancia dessa classe.
    }

    falar() {
        console.log(`Meu nome é ${this.nome}`);
    }
}

const p1 = new Pessoa('João'); // passei aqui string, q foi passada pro construtor
p1.falar();

// vai mostrar o esperado, meu nome é joão

const pessoa = nome => {
    return {
        falar: () => console.log(`Meu nome é ${nome}`); // com Factory aqui, eu nao preciso usar o 'this', pq ele tem consciencia do contexto lexico no qual foi declarado.
    }
}

const p2 = pessoa('João');
p2.falar();

///////////

Transformar este codigo em uma função construtora:
class Pessoa {
    constructor(nome) { // aqui tenho o construtor dessa classe para inicializar variaveis que porventura passemos na hora da construção
        this.nome = nome; // assim que coloquei aqui this.nome , significa que essa variavel 'nome' passou a ser publica, entao vou poder ter acesso a ela sempre q eu quiser a partir da instancia dessa classe.
    }

    falar() {
        console.log(`Meu nome é ${this.nome}`);
    }
}

---------

// os parametros do construtor vao passar a ser parametro dessa funçao a ser criada. o que voce fez dentro do 'constructor', agora, vc faz dentro direto da sua funçao construtora

function Pessoa(nome) {

    this.nome = nome; 

    this.falar = function() { // e para transformar essa funçao pra ficar diretamente no objeto, fiz assim 'this.falar = function()'
        console.log(`Meu nome é ${this.nome}`);
    }
}

const p1 = new Pessoa('João');
p1.falar(); // aqui a instanciação é a mesma

// entao posso criar objeto a partir de uma funçao construtora, de uma classe e criar objeto a partir de uma factory

///////////

IIFE - Função auto invocada, na declaraçao da funçao ja invoca a execuçao da função. ideal pra fugir do escopo global. tudo que voce criar na função será escopo local da função e não escopo global da função. evita manipular algo no escopo global. aqui, voce foge do escopo global, criando função autoinvocada.

(function(){ // criei uma funçao anonima
    console.log("Será executado na hora");
    console.log("Foge do escopo mais abrangente!");
})() // pra finalizar, no final, preciso chamar ele com os ()


//////////

Call & Apply -

function getPreco(imposto = 0, moeda = 'R$')
{
    return `${moeda} ${this.preco * (1 - this.desc) * (1 + imposto)}`;
}

const produto = {
    nome: 'notebook',
    preco: 4589,
    desc: 0.15,
    getPreco // como ja tenho uma funçao com esse nome, ao criar um atributo assim com esse nome ele ja vai associar automaticamente a funçao
}

// se eu fizesse assim:
// global.preco = 18;
// global.desc = 2; 
// funcionaria, pq teria definido globalmente
console.log(getPreco()); // vai dar NaN pq simplesmente nao defini preco e desconto, a nao ser se eu fizesse o que fiz acima, declarando como 'global.preco = 18 e global.desc = 2'
console.log(produto.getPreco()); // outra forma: agora funciona normalmente, pq chamei 'getpreco' a partir de um objeto

// outra forma é a partir do call e apply:

const carro = { preco: 49990, desc: 0.20}; // criei outro objeto
// a partir desse objeto, vou chamar getPreco
console.log(getPreco.call(carro)); // passei como contexto o objeto carro pro valor da execução
console.log(getPreco.apply(carro)); 

// qual a diferença de call e apply? é a chamada nos parametros.
com call, eu passo diretamente eu passo os parametros cada um dos parametros que serao passado da funçao. o 1 parametro sempre é o contexto.
ex:
console.log(getPreco.call(carro, 0.17, '$'));

// com apply, vou passar os parametros dentro de um array
console.log(getPreco.apply(carro, [0.17, '$']));

o contexto poderia ser 'global' tb, ai usaria o global que passamos lá em cima:
console.log(getPreco.apply(global, [0.17, '$']));
console.log(getPreco.call(global, 0.17, '$'));

///////////////////

OBJETOS OO-

// Linguagem procedural
processamento(valor1, valor2, valor3); // voce tem dado e manipula o dado. 

aqui voce tem dados e dentro desses dados voce tem funçao
objeto é a figura central. as figuras que geram objetos podem ser classes, funções, etc.

objeto = {
    valor1,
    valor2,
    valor3,
    processamento(){

    }
}

// na OO voce tem dados, e dentro dos dados voce tem as funções. e voce passa a invocar esses processamentos a partir do dado. o objeto funciona como capsula que agrpa comportamentos e atributos. objeto tem herança, etc.

objeto.processamento();


// Principios importantes:
// 1. abstração - pegar objeto do mundo real e como traduzir esse objeto pra dentro do sistema.
por ex: objeto: carro. carro tem atributos peso, largura, altura, velocidadeMax, velocidadeAtual, tem metodo de ligar, desligar, gerarSom, etc.
mas por ex, se vc fosse funcionario do detran, nao faria sentido criar o método acelerar dentro da função de carro se tivesse q criar um sistema pro detran 

// 2 encapsulamento - ter os detalhes de implementaçao escondidos e mostrar a interface escondida pra que possa interagir com o objeto.
quando voce muda a implementaçao interna, nao necessariamente quem usa aquela implementaçao precisa se adaptar, só é necessario mudar a interface pra todo mundo se adaptar.

alto acoplamento = muitos objetos que tem tudo deles dentro exposto, há muita dependencia entre eles.
é mais importante se preocupar com a comunicaçao dos objetos do que com a implementação.

// 3 herança (prototype) -> [...] É UM [...]
voce herda atributos e comportamentos de uma herança pai.
priorize a composiçao em vez de herança.

// 4 polimorfismo -> multipla formas

////////////


// objeto é coleçao dinamica de pares chave/valor
const produto = new Object // Object é uma funçao, instanciei um objeto aqui.
produto.nome = 'Cadeira';
produto['marca do produto'] = 'Genérica';
produto.preco = 220;
console.log(produto); // vai mostrar nome, marca e preço.


// excluindo atributos de um objeto:
delete produto.preco;
delete produto['marca do produto'];

// agora, ao dar console.log(produto), mostraria apenas 'nome'.

const carro = { // esses valores podem ser outros objetos, array, etc. ali tem o valor proprietario sendo outro objeto, q proprietario tem outro objeto (endereço).
    modelo = 'A4',
    valor: 89000,
    proprietario: {
        nome: 'Raul',
        idade: 56,
        endereco: {
            logradouro: 'Rua ABC',
            numero: 123
        }
    },
    condutores: [{
        nome: 'Junior',
        idade: 42
    }, {
        nome: 'Ana',
        idade: 32
    },
], // temos aqui atributos que é um array, q tem conjunto de objetos
calcularValorSeguro: function() {
    // ...
} // aqui tenho uma funçao dentro do objeto
}

carro.proprietario.endereco.numero = 1000; // posso acessar os atributos a partir da notação ponto
carro['proprietario']['endereco']['logradouro'] = "Av. Paulista"; // posso acessar atributo tb a partir de colchetes
console.log(carro);

delete carro.condutores; // tudo q tiver dentro de condutores será excluindo
delete carro.proprietario.endereco;
delete carro.calcularValorSeguro; 

///////////

Criaçao de objetos -
// usando notaçao literal
const obj1 = {}
console.log(obj1);

// object em JS
console.log(typeof Object, typeof new Object());
ou
const obj = new Object
console.log(obj2);

// Funções construtoras
function Produto(nome, preco, desc){
    this.nome = nome; // aqui eu quis tornar essa variável pública, ela nao ta encapsulada/escondida dentro do objeto, isto é, visivel para fora do objeto. aqui significa que ele pertence a instancia, pq to acessando com 'this'. quando eu criar uma nova instancia de produto, o nome que voce passou estará visivel nessa instancia que será criada
    this.getPrecoComDesconto = () => {
        return preco * (1 - desc);
    } // aqui tenho um metodo que será público tbm. este metodo pertence a instancia que for criada tbm, estará visivel quando instanciar um objeto a partir deste método
}

const p1 = new Produto('Caneta', 7.99, 0.15);
const p2 = new Produto('Notebook', 2998.99, 0.25);
console.log(p1.getPrecoComDesconto(), p2.getPrecoComDesconto());

// Função Factory
function criarFuncionario(nome, salarioBase, faltas){
    return {
        nome,
        salarioBase,
        faltas,
        getSalario(){ // vai calcular o salario baseado nas faltas que o funcionario ter
            return (salarioBase / 30) * (30 - faltas);
        }
    }
}

const f1 = criarFuncionario('João', 7980, 4);
const f2 = criarFuncionario('Maria', 11400, 1);
console.log(f1.getSalario(), f2.getSalario());

// Object.create é outra forma de criar objeto
const filha = Object.create(null); // Quando null é passado como argumento para Object.create, isso significa que o novo objeto não terá nenhum prototype. Isso resulta em um objeto que não herda propriedades ou métodos de nenhum outro objeto.
filha.nome = 'Ana';
console.log(filha);

// Criando objeto com JSON.parse
const fromJSON = JSON.parse('{"info": "Sou um JSON"}'); // ele converteu essa string JSON que está em em aspas simples em uma objeto javascript. 
console.log(fromJSON.info); // posso acessar como objeto. 

//////////////

Objetos Constantes - 
const pessoa = { nome: João };
pessoa.nome = 'Pedro';
console.log(pessoa); // funciona normalmente, embora seja constante, a referencia é ao 'nome'

// agora, pra eu não mexer mais em um Objeto, como eu faria?
Object.freeze(pessoa); // quando dá 'Object.freeze', não poderá mais usar nada do Object, nem adicionar, nem mudar, nem remover, nem nada.
pessoa.nome = 'Maria';
pessoa.end = 'Rua ABC';
delete pessoa.nome; // também não irá funcionar.
console.log(pessoa.nome); // isso não irá gerar um erro, mas 'pessoa.nome' continuará sendo 'Pedro'. 
console.log(pessoa); // não irá mostrar 'Rua ABC', pelo fato que voce deu freeze em 'pessoa'.

// com o Object.freeze(pessoa), nada abaixo disso irá funcionar mais.
// pra criar e nunca mais mexer, façamos:
const pessoaConstante = Object.freeze({nome: 'João'});

console.log(pessoaConstante); // mostra apenas 'nome:João', e nada mais vai alterar nisso

///////////////////

Métodos Getters e Setters-
Metodo get - le o valor de uma variavel/atributo
Método set - altera o valor de uma variável
metodos getters e setters são valores que podem ser acessados

_valor = 1; // usar _ antes do nome da variavel é uma convenção do javascript para dizer q o atributo é pretendido a ser privado

const sequencia = {
    _valor: 1,
    get valor() { return this._valor++},
    set valor(valor){
        if(valor > this._valor)
        {
            this._valor = valor;
        }
    }
}

console.log(sequencia.valor, sequencia.valor); // embora eu esteja, teoricamente, acessando um atributo, ele ta, na vdd, acessando o metodo get e o metodo set. irá mostrar 1 e 2.
sequencia.valor = 1000;
console.log(sequencia.valor, sequencia.valor); // mostru 1000 e 1001, metodo get e metodo set
sequencia.valor = 900;
console.log(sequencia.valor, sequencia.valor); // vai mostrar 1002 e 1003, pois o valor q voce ta setando é menor que o valor que já tem no get (1001 agora, pq era 1000 q setei e +1 pq executei), então ele vai simplesmente ignorar

//////////

Funções importantes de Objeto
const pessoa = {
    nome: 'Rebeca',
    idade: 2,
    peso: 13
}

console.log(Object.keys(pessoa)); // object.keys pega todas as chaves de um objeto, no caso, 'pessoa'. vai mostrar: 'nome idade, peso'.
console.log(Object.values(pessoa)); // peguei uma lista dos valores de 'pessoa', no caso, mostra 'Rebeca, 2, 13'
console.log(Object.entries(pessoa)); // vai me dar um array com todos os subarrays que vai ter a chave e o valor, no caso, me retorna: [ ['nome', 'Rebeca'], ['idade', 2], ['peso', 13] ]
/\ // posso até percorrer através de um array:

Object.entries(pessoa).forEach(e => { // a partir do foreach, vou percorrer os elementos (e) que foram gerados a partir de Object.entries
    console.log(`${e[0]}: ${e[1]}`)
})

// usando destructuring, para ficar mais claro:
Object.entries(pessoa).forEach(([chave, valor]) => {
    console.log(`${chave}, ${valor}`); // agora fica mais claro saber o que é chave e o que é valor
})

Object.defineProperty // aqui, voce define uma propriedade de um objeto. pode definir dinamicamente, como fizemos acima com a notaçao literal { ... }, notaçao ponto, etc. mas pra q funçao entao? pq posso definir algumas caracteristicas pra uma propriedade (Atributo), como por ex essa propriedade pode ou não ser alterada, ficará ou não visível, etc.
ex:
Object.defineProperty(pessoa, 'dataNascimento', {
    enumerable: true,
    writable: false,
    value: '01/01/2019'
})

pessoa.dataNascimento = '01/01/2017';
console.log(pessoa.dataNascimento);
console.log(Object.keys(pessoa)); // verá que vai mostrar 'nome, idade, peso, dataNascimento'. se colocar 'enumerable: false', ele não vai mostrar dataNascimento.

// Object.assign
const dest = { a: 1}
const o1 = {b: 2}
const o2 = {c: 3, a: 4}
const obj = Object.assign(dest, o1, o2); // o object.assign pega o objeto de destino, que é o objeto que vai receber os atributos, no caso, 'dest', e todos os parametros que voce passou depois de 'dest', vai concatenar com os objetos que voce passou no primeiro parametro (no caso, o1 e o2 vão concatenar com os objetos que ja tem no dest. no caso, dentro de 'dest' vai ter 'b: 2, c:3 e a:4', 'a' já exisita como valor 1, mas foi sobrescrito por 4, vai tudo concatenar com o 'obj'). se eu der Object.freeze(obj) embaixo, nada mais nele poderá ser mudado.

/////////////

Herança é um principio da OO que faz com que voce receba atributos e comportamentos do pai, e 'reuse' códigos. em herança vc só tem um ancestral, em composiçao vc pode ser composto de multiplos objetos, por isso prefira composição a herança.
em javascript, a herança é uma herança baseada em prototipos.
prototipo é tipo: vc tem um objeto com atributo 'nome'. voce tenta acessar o atributo nome e ele vai pegar o atributo do proprio objeto. se voce ta tentando pegar um atributo cor do cabelo, e esse objeto que ta tentando procurar nao tem cor do cabelo, o objeto tem referencia do seu Pai, que se vc nao achou uma propriedade em seu objeto, procura o mesmo atributo no seu prototipo, caso tenha, procurando no pai do meu pai, e assim indo, se não achar, dirá q é undefined, se achar, ele devolve o valor.
vejamos, temos um objeto chamado ferrari, e tem um atributo chamado [[Prototype]], por padrão ele aponta para Object.prototype. nem sempre vc aponta pra Object.prototype. o atributo prototype so ta disponivel dentro de uma função.
OBS:
[[Prototype]] != prototype (atributo)

const ferrariNova = {
    modelo: 'F40',
    velMax: 400
}

const volvo = {
    modelo: 'V40',
    velMax: 320
}

console.log(ferrariNova.__proto__); // com isso, consigo acessar o prototipo do meu objeto ferrariNova, e se eu tentar acessar um atributo dentro de ferrari, e nao achar, ele vai procurar o mesmo atributo dentro do meu prototipo. ao executar, dirá q é um objeto vazio, {}, mas existe, ta presente.

console.log(ferrariNova.__proto__ === Object.prototype); // verá q vai dar true, pois o [[Prototype]] aponta, por padrao, para o Object.prototype.

[[Prototype]], aqui, é o __proto__

console.log(volvo.__proto__ === Object.prototype); // qq outro objeto q vc crie, com isso, ira apontar pra Object.prototype

console.log(Object.prototype.__proto__ === null); // nao tem ninguem mais acima de prototype, portanto é nulo

// isso não vale se vc estiver criando sua funçao construtora

function MeuObjeto() {}
    console.log(typeof Object, typeof MeuObjeto);
    console.log(Object.prototype, MeuObjeto.prototype);


////////

Cadeia de protótipos (prototype chain)

const avo = { attr1: 'A' }
const pai = { __proto__: avo, attr2: 'B'}; // pra eu referenciar que o pai tem o prototipo 'avo', eu tenho q atribuir na propriedade __proto__: avo.
const filho = {__proto__: pai, attr3: 'C'};

// o avo tem o atributo1, q é 'A', o pai tem attr2 q é o B, e o filho tem attr3 q é 'C'. o filho tem como prototipo o pai, o pai tem como prototipo o avo, e o avo tem como prototipo o Object.prototype.
console.log(filho.attr1); // vai mostrar 'A'

Agora, se eu der, acima do avo:
Object.prototype.attr0 = 'Z'; // não é recomendado
console.log(filho.attr0, filho.attr1, filho.attr2, filho.attr3); // vai mostrar 'Z', pq ele vai procurar no pai, depois no avo, nao achou nenhum attr0, entao agr vai procurar no prototype, e achou, mas este caso não é muito recomendado.

const carro = {
    velAtual: 0,
    velMax: 200,
    acelerarMais(delta){
        if(this.velAtual + delta <= this.velMax) {
            this.velAtual += delta;
        }
        else {
            this.velAtual = this.velMax;
        }
    },
    status() {
        return `${this.velAtual}Km/h de ${this.velMax}Km/h`;
    }
}

const ferrari = {
    modelo: 'F40',
    velMax: 324 // no momento que defino a velMax, esse atributo vai sombrear o atributo original de 'carro', então vou ter aqui o shadowing, que é o 'sombreamento', onde temos uma variavel local e essa variavel pode sombrear variavel de escopo mais abrangente
}

const volvo = {
    modelo: 'V40',
    status() {
        // sombreei a função 'status', vou usar ela com uma funçao a mais. assim como uso 'this' pra referenciar ao objeto atual, eu uso 'super' pra referenciar o meu prototipo. 
        return `${this.modelo}: ${super.status()}`; // estou sombreando a minha funçao status através do objeto 'volvo', por enquanto ela é uma funçao independente. com o 'super' eu uso a função do meu prototipo, isto é, status do prototipo, no caso, carro.
    }
}

Object.setPrototypeOf(ferrari, carro); // estabeleci uma relação entre ferrari e carro. isto é, ferrari tem 'carro' como seu prototipo. 'setPrototypeOf' é um método especificado pela linguagem, onde tiver JS, ele funcionará. primeiro tenho o objeto (ferrari), depois é o prototipo daquele objeto (carro).

Object.setPrototypeOf(volvo, carro);

console.log(ferrari);
console.log(volvo);

volvo.acelerarMais(100);
console.log(volvo.status());

ferrari.acelerarMais(300);
console.log(ferrari.status()); // no caso, vai chamar o proprio metodo status de 'carro', ja que nao sobrescrevi em 'ferrari'

///////////

Herança #3-
const pai = {
    nome: 'Pedro',
    corCabelo: 'Preto'
}

const filha1 = Object.create(pai); // vai criar o objeto filha1 tendo como prototipo 'pai'. define como prototipo o objeto que voce passou como parametro. eu passo o objeto que eu quero que seja o prototipo do objeto que está sendo criado a partir do método Object.create
filha1.nome = 'Ana'; // já alterei o nome da filha. ja tenho acesso a 'nome' e 'corcabelo'. aqui ja tenho objeto normal, ele aponta pro objeto que voce usou como prototipo no 'Object.create', no caso, 'pai'.
console.log(filha1.corCabelo); // vai mostrar 'preto'

// ja posso ate criar outros atributos, dizer se o atributo sera enumerado, sera escrito, etc. \/
const filha2 = Object.create(pai, { 
    nome: { value: 'Bia', writable: false, enumerable: true} // não poderá ser escrito ('nome' será 'bia' e não poderá ser mudado) e poderá ser listado (enumerable), então pode ajudar se for usar object.key ou foreach 
}); // o 2º parametro desse objeto será todos os atributos que eu quero adicionar

console.log(filha2.nome);

for(let key in filha2) {
    filha2.hasOwnProperty(key) ?
        console.log(key) : console.log(`Por herança: ${key}`);
} // for in aqui é a possibilidade de verificar se uma determinada propriedade pertence ou não ao objeto que voce esta percorrendo no momento. no caso, aqui, hasownProperty se retornar true significa que o atributo pertence ao proprio objeto, senão significa que vc recebeu o atributo a partir da cadeia de prototipos, isto é, a partir da cadeia de herança.